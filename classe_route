#defining route class
import numpy as np
from dowload_data import dataset_1, vehicles


def gamma(f,t):
    res = 0
    w = (2*pi)/86400
    for n in range (0,4): 
        alpha_f_n = vehicles.iloc[f]['fourier_cos_'+ str(n)]
        beta_f_n = vehicles.iloc[f]['fourier_sin_'+ str(n)]
        res += alpha_f_n*cos(n*w*t) + beta_f_n*sin(n*w*t)
    return res


def convert_x(phi_i, phi_j): 
    ro = 6.371e6
    return ro*((2*pi)/360)*(phi_j-phi_i)


def convert_y(lambda_i, lambda_j): 
    ro = 6.371e6
    phi_0 = 48.764246
    return ro*(cos(((2*pi)/360)*phi_0))*((2*pi/360)*(lambda_j-lambda_i))


def travel_time(f,i,j,t, instance): 
    vehicle_idx = f - 1  
    phi_i, lambda_i = instance.iloc[i]['latitude'], instance.iloc[i]['longitude']
    phi_j, lambda_j = instance.iloc[j]['latitude'], instance.iloc[j]['longitude']
    speed_factor = gamma(vehicle_idx, t) 
    base_speed = vehicles.iloc[vehicle_idx]['speed']
    actual_speed = base_speed * speed_factor 
    manhattan_dist = abs(convert_x(phi_i, phi_j)) + abs(convert_y(lambda_i, lambda_j)) 
    p_f = vehicles.iloc[vehicle_idx]['parking_time']
    return manhattan_dist/actual_speed + p_f

def delta_m(i,j, instance): 
    phi_i, lambda_i = instance.iloc[i]['latitude'], instance.iloc[i]['longitude']
    phi_j, lambda_j = instance.iloc[j]['latitude'], instance.iloc[j]['longitude']
    return abs(convert_x(phi_i, phi_j)) + abs(convert_y(lambda_i, lambda_j)) 

def delta_e(i,j, instance): 
    phi_i, lambda_i = instance.iloc[i]['latitude'], instance.iloc[i]['longitude']
    phi_j, lambda_j = instance.iloc[j]['latitude'], instance.iloc[j]['longitude']
    return sqrt(abs(convert_x(phi_i, phi_j))**2 + abs(convert_y(lambda_i, lambda_j))**2)

def delta_M(instance): 
    """
    outputs matrice of manhattan distances M[i][j]
    """
    n_locations = len(instance)
    M = np.zeros((n_locations, n_locations))
    for i in range(n_locations): 
        for j in range(n_locations): 
            M[i,j] = delta_m(i,j, instance)
    return M


def delta_E(instance): 
    """
    outputs matrice of euclidian distances M[i][j]
    """
    n_locations = len(instance)
    E = np.zeros((n_locations, n_locations))
    for i in range(n_locations): 
        for j in range(n_locations): 
            E[i,j] = delta_e(i,j, instance)
    return E


class Route:
    def __init__(self,family: int, n_orders:int, visited : list[int], arrival_times : list[int], departure_times: list[int]):
        self.family = family
        self.n_orders = n_orders
        self.visited = visited
        self.arrival_times = arrival_times
        self.departure_times = departure_times
    def c_rental(self) -> float:
        #return int(vehicles.loc[vehicles['family'] == self.family, 'rental_cost'].iloc[0])
        return vehicles.loc[vehicles['family'] == self.family, 'rental_cost'].iloc[0]
    
    def c_fuel(self) -> float:
        c_f = vehicles.loc[vehicles['family'] == self.family, 'fuel_cost'].iloc[0]
        total = sum(delta_m(self.visited[i], self.visited[i+1]) for i in range(self.n_orders+1)) #otherwise
        return float(c_f*total)
    
    def c_radius(self) -> float:
        c_r = vehicles.loc[vehicles['family'] == self.family, 'radius_cost'].iloc[0]
        max_val = max(delta_e(self.visited[i], self.visited[j]) 
              for i in range(self.n_orders+1) 
              for j in range(i+1, self.n_orders+2))
        print(max_val)
        return float((c_r/4)*(max_val**2))
    
    def transported_weight(self) -> int :
        return sum(dataset_1.iloc[self.visited[i]]['order_weight'] for i in range(1,self.n_orders+1))
    
    def total_cost(self) -> float:
        return self.c_rental()+self.c_fuel()+self.c_radius()
    

